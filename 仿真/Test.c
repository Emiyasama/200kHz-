
/******************************************************************************
文 件 名：main.c
编    制：niuws
版 本 号：V1.0（CCS3.3.83.16)
日    期：20091110
说    明：调用初始化，系统主循环
修改记录：//每条修改记录应包括编号、修改日期、修改者及修改内容简述。
          //如：1、日期：          修改者：           修改内容：
******************************************************************************/
#define  nWS_GnOBnES
#include <math.h>
#include "app_cfg.h"


typedef signed   long long           sint64; 


const sint16 COS_TAB128[] =
{
	32767 , 32728 , 32609 , 32412 , 32137 , 31785 , 31356 , 30852 , 30273 , 29621 ,
    28898 , 28105 , 27245 , 26319 , 25329 , 24279 , 23170 , 22005 , 20787 , 19519 ,
    18204 , 16846 , 15446 , 14010 , 12539 , 11039 ,  9512 ,  7962 ,  6393 ,  4808 ,
     3212 ,  1608 ,     0 , -1608 , -3212 , -4808 , -6393 , -7962 , -9512 ,-11039 ,
   -12539 ,-14010 ,-15446 ,-16846 ,-18204 ,-19519 ,-20787 ,-22005 ,-23170 ,-24279 ,
   -25329 ,-26319 ,-27245 ,-28105 ,-28898 ,-29621 ,-30273 ,-30852 ,-31356 ,-31785 ,   
   -32137 ,-32412 ,-32609 ,-32728
};

const sint16 SIN_TAB128[] =
{
        0 ,  1608 ,  3212 ,  4808 ,  6393 ,  7962 ,  9512 , 11039 , 12539 , 14010 ,
    15446 , 16846 , 18204 , 19519 , 20787 , 22005 , 23170 , 24279 , 25329 , 26319 ,
    27245 , 28105 , 28898 , 29621 , 30273 , 30852 , 31356 , 31785 , 32137 , 32412 ,
    32609 , 32728 , 32767 , 32728 , 32609 , 32412 , 32137 , 31785 , 31356 , 30852 ,
    30273 , 29621 , 28898 , 28105 , 27245 , 26319 , 25329 , 24279 , 23170 , 22005 ,
    20787 , 19519 , 18204 , 16846 , 15446 , 14010 , 12539 , 11039 ,  9512 ,  7962 ,    
     6393 ,  4808 ,  3212 ,  1608
};

const sint16 cos_sin_128pt[] =
{
    32767 , 32728 , 32609 , 32412 , 32137 , 31785 , 31356 , 30852 , 30273 , 29621 ,
    28898 , 28105 , 27245 , 26319 , 25329 , 24279 , 23170 , 22005 , 20787 , 19519 ,
    18204 , 16846 , 15446 , 14010 , 12539 , 11039 ,  9512 ,  7962 ,  6393 ,  4808 ,
     3212 ,  1608 ,     0 , -1608 , -3212 , -4808 , -6393 , -7962 , -9512 ,-11039 ,
   -12539 ,-14010 ,-15446 ,-16846 ,-18204 ,-19519 ,-20787 ,-22005 ,-23170 ,-24279 ,
   -25329 ,-26319 ,-27245 ,-28105 ,-28898 ,-29621 ,-30273 ,-30852 ,-31356 ,-31785 ,   
   -32137 ,-32412 ,-32609 ,-32728, 

        0 ,  1608 ,  3212 ,  4808 ,  6393 ,  7962 ,  9512 , 11039 , 12539 , 14010 ,
    15446 , 16846 , 18204 , 19519 , 20787 , 22005 , 23170 , 24279 , 25329 , 26319 ,
    27245 , 28105 , 28898 , 29621 , 30273 , 30852 , 31356 , 31785 , 32137 , 32412 ,
    32609 , 32728 , 32767 , 32728 , 32609 , 32412 , 32137 , 31785 , 31356 , 30852 ,
    30273 , 29621 , 28898 , 28105 , 27245 , 26319 , 25329 , 24279 , 23170 , 22005 ,
    20787 , 19519 , 18204 , 16846 , 15446 , 14010 , 12539 , 11039 ,  9512 ,  7962 ,    
     6393 ,  4808 ,  3212 ,  1608 
};

const sint16 cos_sin_64pt[] =
{
    32767 , 32609 , 32137 , 31356 , 30273 , 28898 , 27245 , 25329 , 23170 , 20787 ,
    18204 , 15446 , 12539 ,  9512 ,  6393 ,  3212 ,     0 , -3212 , -6393 , -9512 ,
   -12539 ,-15446 ,-18204 ,-20787 ,-23170 ,-25329 ,-27245 ,-28898 ,-30273 ,-31356 ,
   -32137 ,-32609 ,
        0 ,  3212 ,  6393 ,  9512 , 12539 , 15446 , 18204 , 20787 , 23170 , 25329 ,
    27245 , 28898 , 30273 , 31356 , 32137 , 32609 , 32767 , 32609 , 32137 , 31356 ,
    30273 , 28898 , 27245 , 25329 , 23170 , 20787 , 18204 , 15446 , 12539 ,  9512 ,
     6393 ,  3212  
};

const sint16 COS_TAB64[] =
{
	32767 , 32609 , 32137 , 31356 , 30273 , 28898 , 27245 , 25329 , 23170 , 20787 ,
    18204 , 15446 , 12539 ,  9512 ,  6393 ,  3212 ,     0 , -3212 , -6393 , -9512 ,
   -12539 ,-15446 ,-18204 ,-20787 ,-23170 ,-25329 ,-27245 ,-28898 ,-30273 ,-31356 ,
   -32137 ,-32609 
};

const sint16 SIN_TAB64[] =
{
	 0 ,  3212 ,  6393 ,  9512 , 12539 , 15446 , 18204 , 20787 , 23170 , 25329 ,
    27245 , 28898 , 30273 , 31356 , 32137 , 32609 , 32767 , 32609 , 32137 , 31356 ,
    30273 , 28898 , 27245 , 25329 , 23170 , 20787 , 18204 , 15446 , 12539 ,  9512 ,
     6393 ,  3212
};

sint32 DataR[128];
sint32 DataI[128];
sint32 HO[64];

//==============================================================================================
void FFT128p(void)
{
	uint16 i,j,k,m,n;
	sint32 tr,ti,temp1,temp2;	

	for(i = 0;i < 128;i ++)											// 序列反转
	{
		m = i << 1;
		j = 0;
		for(n = 0;n < 7;n ++)
		{
			j >>= 1;
			if(m & 0x80)
			{
				j |= 0x40;
			}
			m <<= 1;			
		}     
        
		if(j > i)
		{
		  	temp1 = DataR[j];
			DataR[j] = DataR[i];
			DataR[i] = temp1;
		}
        
		DataI[i] = 0;
	}

	for(i = 1;i <= 7;i ++)	  										// 128 = 2 ^ 7
	{
		m = 1 << (i - 1);   										// m = 2 ^ (i - 1)
		for(j = 0;j <= m - 1;j ++)
		{
			n = 1 << (7 - i);   									// n = 2 ^ (7 - i)
			n *= j;	 												// n = 2 ^ (7 - i) * j
			for(k = j;k < 128;k += 2 * m)
			{
			    tr = DataR[k];
				ti = DataI[k];
				temp1 = DataR[k + m];
				temp2 = DataI[k + m];

				DataR[k] 	 = tr + ((sint64)temp1 * COS_TAB128[n] + (sint64)temp2 * SIN_TAB128[n]) / 32768;
				DataR[k + m] = tr - ((sint64)temp1 * COS_TAB128[n] + (sint64)temp2 * SIN_TAB128[n]) / 32768;				
                DataI[k] 	 = ti - ((sint64)temp1 * SIN_TAB128[n] - (sint64)temp2 * COS_TAB128[n]) / 32768;				
				DataI[k + m] = ti + ((sint64)temp1 * SIN_TAB128[n] - (sint64)temp2 * COS_TAB128[n]) / 32768;
			}
		}
	}
	
    for(i = 0;i < 32;i ++)
	{
	    HO[i] = sqrt((sint64)DataR[i] * DataR[i] + (sint64)DataI[i] * DataI[i]) / 64;
	}
}

sint16 comp_cnt = 0;
void FFT64p(void)
{
	uint16 i,j,k,m,n;
	sint32 tr,ti,temp1,temp2;	 
	
	for(i = 0;i < 64;i ++)											// 序列反转
	{
		m = i << 2;
		j = 0;
		for(n = 0;n < 6;n ++)  										// i按照二进制180度翻转
		{
			j >>= 1;
			if(m & 0x80)
			{
				j |= 0x20;
			}
			m <<= 1;			
		}     									

		if(j > i)
		{
		  	temp1 = DataR[j];
			DataR[j] = DataR[i];
			DataR[i] = temp1;
		}
        
		DataI[i] = 0;
	}

	for(i = 1;i <= 6;i ++)	  										// 64 = 2 ^ 6
	{
		m = 1 << (i - 1);   										// m = 2 ^ (i - 1)
		for(j = 0;j <= m - 1;j ++)
		{
			n = 1 << (6 - i);   									// n = 2 ^ (6 - i)
			n *= j;	 
																	// n = 2 ^ (6 - i) * j
			for(k = j;k < 64;k += 2 * m)
			{
				comp_cnt ++;

			    tr = DataR[k];
				ti = DataI[k];			   	
				temp1 = DataR[k + m];
				temp2 = DataI[k + m];

				DataR[k] 	 = tr + ((sint64)temp1 * COS_TAB64[n] + (sint64)temp2 * SIN_TAB64[n]) / 32768;                
				DataR[k + m] = tr - ((sint64)temp1 * COS_TAB64[n] + (sint64)temp2 * SIN_TAB64[n]) / 32768;
				DataI[k] 	 = ti - ((sint64)temp1 * SIN_TAB64[n] - (sint64)temp2 * COS_TAB64[n]) / 32768;
				DataI[k + m] = ti + ((sint64)temp1 * SIN_TAB64[n] - (sint64)temp2 * COS_TAB64[n]) / 32768;
			}
		}
	}
    for(i = 0;i < 32;i ++)
	{
	    HO[i] = sqrt((sint64)DataR[i] * DataR[i] + (sint64)DataI[i] * DataI[i]) / 32;
	}
}

//==============================================================================================
void ACSample128(void)
{
    short int i;
	short int deti = 0;
    for(i = 0;i < 128;i++)
	{
	    DataR[i] = 22000 * cos(2 * 3.141593 * 1 * (i + deti) / 128);
        //DataR[i] += 22000 * cos(2 * 3.141593 * 2 * (i + deti) / 128);
		//DataR[i] += 22000 * cos(2 * 3.141593 * 3 * (i + deti) / 128);
		//DataR[i] += 22000 * cos(2 * 3.141593 * 4 * (i + deti) / 128);
		//DataR[i] += 22000 * cos(2 * 3.141593 * 5 * (i + deti) / 128);
		//DataR[i] += 22000 * cos(2 * 3.141593 * 6 * (i + deti) / 128);
		//DataR[i] += 22000 * cos(2 * 3.141593 * 7 * (i + deti) / 128);
		//DataR[i] += 22000 * cos(2 * 3.141593 * 8 * (i + deti) / 128);
		//DataR[i] += 22000 * cos(2 * 3.141593 * 9 * (i + deti) / 128);

	}
}

void ACSample64(void)
{
    short int i;
	short int deti = 8;
    for(i = 0;i < 64;i++)
	{
	    DataR[i] = 22000 * cos(2 * 3.141593 * 1 * (i + deti) / 64);
        //DataR[i] += 22000 * cos(2 * 3.141593 * 2 * (i + deti) / 64);
		//DataR[i] += 22000 * cos(2 * 3.141593 * 3 * (i + deti) / 64);
		//DataR[i] += 22000 * cos(2 * 3.141593 * 4 * (i + deti) / 64);
		//DataR[i] += 22000 * cos(2 * 3.141593 * 5 * (i + deti) / 64);
		//DataR[i] += 22000 * cos(2 * 3.141593 * 6 * (i + deti) / 64);
		//DataR[i] += 22000 * cos(2 * 3.141593 * 7 * (i + deti) / 64);
		//DataR[i] += 22000 * cos(2 * 3.141593 * 8 * (i + deti) / 64);
		//DataR[i] += 22000 * cos(2 * 3.141593 * 31 * (i + deti) / 64);
	}
}

//==============================================================================================

extern void RFFT64(sint32 *data_r,sint32 *data_i);
extern void RFFT128(sint32 *data_r,sint32 *data_i);

int main(void)
{ 
	sint32 i;
	
	STM32Init();  
	//ACSample128();
	//FFT128p();
	ACSample128();
	RFFT128(&DataR[0],&DataI[0]);

   	//ACSample64();
  	//FFT64p();
  	//RFFT64(&DataR[0],&DataI[0]);
 	
  	for(i = 0;i < 64;i ++)
	{
	    HO[i] = sqrt((sint64)DataR[i] * DataR[i] + (sint64)DataI[i] * DataI[i]) / 1;
	}

	while(1);
}

//===========================================================================
// No more.
//===========================================================================











